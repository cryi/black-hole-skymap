<!DOCTYPE html>
<html>
	<head>
		<title>Black Hole Iterative Skymap - WebGL</title>
		
		<script language='javascript' type='text/javascript' src='../js/jquery-1.10.0.min.js'></script>
		<script language='javascript' type='text/javascript' src='../js/util.js'></script>
		<script language='javascript' type='text/javascript' src='../js/gl-matrix-min.js'></script>
		<script language='javascript' type='text/javascript' src='../js/gl-util.js'></script>
		<script language='javascript' type='text/javascript' src='../js/mouse3d.js'></script>
		<script language='javascript' type='text/javascript' src='main.js'></script>
		
<script type='text/javascript'>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-17312646-1']);
_gaq.push(['_trackPageview']);
(function() {
	var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

		<script id='shader-defs' type='x-shader/x-fragment'>
#define DLAMBDA 0.1
#define M_PI 3.14159265358979311599796346854418516159057617187500
#define ITERATIONS 1

#define SCHWARZSCHILD_SPHERIC
//#define ALCUBIERRE

#ifdef SCHWARZSCHILD_SPHERIC
#define EVENT_HORIZON_RADIUS	1.
#define COORDINATE_CENTER	vec3(20., 0., 0.);	//working but not without some numerical instabilities
#define TO_COORDINATES(v)	euclidianToSpheric(v)
#define FROM_COORDINATES(v)	sphericToEuclidian(v)
#endif

#ifdef ALCUBIERRE
#define COORDINATE_CENTER		vec3(0., 3., 0.);
#define TO_COORDINATES(v)		(v)
#define FROM_COORDINATES(v)		(v)
#define WARP_BUBBLE_RADIUS		2.
#define WARP_BUBBLE_DISTANCE	2.
#define WARP_BUBBLE_VELOCITY	.9
#define	WARP_THICKNESS			.1
#endif

/*
x = r
y = polar angle
z = inclination angle
*/
		
vec4 euclidianToSpheric(vec4 xyzt) {
	vec4 rhpt;
	float r2 = length(xyzt.xy);	//length in xy
	rhpt.x = length(xyzt.xyz);	//radial coordinate / length in xyz
	rhpt.y = atan(xyzt.y, xyzt.x);			//polar coordinate / angle about z axis
	rhpt.z = atan(r2, xyzt.z);				//inclination coordinate / angle from positive z axis to negative z axis
	rhpt.w = xyzt.w;

	rhpt.y = mod(rhpt.y, 2. * M_PI);
	rhpt.z = mod(rhpt.z, M_PI);

	return rhpt;
}

vec4 sphericToEuclidian(vec4 rhpt) {
	vec4 xyzt;
	xyzt.x = rhpt.x * cos(rhpt.y) * sin(rhpt.z);
	xyzt.y = rhpt.x * sin(rhpt.y) * sin(rhpt.z);
	xyzt.z = rhpt.x * cos(rhpt.z);
	xyzt.w = rhpt.w;
	return xyzt;
}

float tanh(float x) {
	float exp2x = exp(2. * x);
	return (exp2x - 1.) / (exp2x + 1.);
}

float sech(float x) {
	float expx = exp(x);
	return 2. * expx / (expx * expx + 1.);
}

float sechSq(float x) {
	float y = sech(x);
	return y * y;
}
		</script>
		<script id='init-light-vsh' type='x-shader/x-vertex'>
attribute vec3 vtx;
varying vec3 pos;
uniform mat4 mvMat;
uniform mat4 projMat;
void main() {
	vec4 mvpos = mvMat * vec4(vtx, 1.);
	pos = normalize(mvpos.xyz);
	gl_Position = projMat * vec4(vtx, 1.);
}
		</script>
		<script id='init-light-fsh' type='x-shader/x-vertex'>
varying vec3 pos;

void main() {
	//"null geodesic" means that the time component squared is equal to the space component squared
	vec4 relDirEnd = vec4(normalize(pos), 1.);
	vec4 rel = vec4(0., 0., 0., 0.);

	//center coordinates at the stellar body center
	rel.xyz -= COORDINATE_CENTER;
	relDirEnd.xyz -= COORDINATE_CENTER;

	//convert to spherical coordinates for iteration
	rel = TO_COORDINATES(rel);
	
	//find the difference of a vector pointing in the initial direction, in the black hole's spherical coordinates
	relDirEnd = TO_COORDINATES(relDirEnd);

	//get the direction difference in spheric coordinates
	vec4 relDiff = relDirEnd - rel;
	
	//...and start us off in the view plane
	rel = relDirEnd;

	$assign
}	
		</script>
		<script id='iterate-light-vsh' type='x-shader/x-vertex'>
attribute vec2 vtx;
varying vec2 tc;
uniform mat4 mvMat;
uniform mat4 projMat;
void main() {
	tc = vtx;
	gl_Position = projMat * mvMat * vec4(vtx.x, vtx.y, 0., 1.); 
}	
		</script>
		<script id='iterate-light-fsh' type='x-shader/x-vertex'>
uniform sampler2D posTex;
uniform sampler2D velTex;
varying vec2 tc;
void main() {

	vec4 rel = texture2D(posTex, tc);
	vec4 relDiff = texture2D(velTex, tc);
	
	//integrate along geodesic
	for (int i = 0; i < ITERATIONS; i++) {
		//-x''^a = conn^a_bc x'^b x'^c
		vec4 negRelDiff2;
		
#ifdef SCHWARZSCHILD_SPHERIC
		rel.y = mod(rel.y, 2. * M_PI);
		rel.z = mod(rel.z, 2. * M_PI);

		float radius = rel.x;
		float radiusFromEventHorizon = radius - EVENT_HORIZON_RADIUS;
		float cosPhi = cos(rel.z);
		float sinPhi = sin(rel.z);
		float cotPhi = cosPhi / sinPhi;

		negRelDiff2.w = EVENT_HORIZON_RADIUS / (radius * radiusFromEventHorizon) * relDiff.w * relDiff.x;
		negRelDiff2.x = EVENT_HORIZON_RADIUS * radiusFromEventHorizon / (2. * radius * radius * radius) * relDiff.w * relDiff.w
			- EVENT_HORIZON_RADIUS / (2. * radius * radiusFromEventHorizon) * relDiff.x * relDiff.x
			- radiusFromEventHorizon * sinPhi * sinPhi * relDiff.y * relDiff.y
			- radiusFromEventHorizon * relDiff.z * relDiff.z
		;
		negRelDiff2.y = 2. / radius * relDiff.x * relDiff.y + 2. * cotPhi * relDiff.y * relDiff.z;
		negRelDiff2.z = 2. / radius * relDiff.x * relDiff.z - sinPhi * cosPhi * relDiff.y * relDiff.y;
#endif

#ifdef ALCUBIERRE
		float rs = length(rel.xyz - vec3(WARP_BUBBLE_DISTANCE, 0., 0.));
		float sigmaFront = WARP_THICKNESS * (rs + WARP_BUBBLE_RADIUS);
		float sigmaCenter = WARP_THICKNESS * rs;
		float sigmaBack = WARP_THICKNESS * (rs - WARP_BUBBLE_RADIUS);
		float f = (tanh(sigmaFront) - tanh(sigmaBack)) / (2. * tanh(sigmaCenter));
		float sechDiff = sechSq(sigmaFront) - sechSq(sigmaBack);
		float dfScalar = sechDiff / (2. * rs * tanh(sigmaCenter));
		float ft = -WARP_BUBBLE_VELOCITY * WARP_THICKNESS * (rel.x - WARP_BUBBLE_DISTANCE) * dfScalar;
		float fx = WARP_THICKNESS * (rel.x - WARP_BUBBLE_DISTANCE) * dfScalar;
		float fy = WARP_THICKNESS * (rel.y) * dfScalar;
		float fz = WARP_THICKNESS * (rel.z) * dfScalar;

		negRelDiff2.w = f * f * fx * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY * relDiff.w * relDiff.w
			- 2. * f * fx * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY * relDiff.w * relDiff.x
			- 2. * f * fy * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY / 2. * relDiff.w * relDiff.y
			- 2. * f * fz * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY / 2. * relDiff.w * relDiff.z
			+ fx * WARP_BUBBLE_VELOCITY * relDiff.x * relDiff.x
			+ 2. * fy * WARP_BUBBLE_VELOCITY / 2. * relDiff.x * relDiff.y
			+ 2. * fz * WARP_BUBBLE_VELOCITY / 2. * relDiff.x * relDiff.z
		;
		negRelDiff2.x = (f * f * f * fx * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY - f * fx * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY - ft * WARP_BUBBLE_VELOCITY) * relDiff.w * relDiff.w
			- 2. * f * f * fx * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY * relDiff.w * relDiff.x
			- 2. * (f * f * fy * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY + fy * WARP_BUBBLE_VELOCITY) / 2. * relDiff.w * relDiff.y
			- 2. * (f * f * fz * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY + fz * WARP_BUBBLE_VELOCITY) / 2. * relDiff.w * relDiff.z
			+ f * fx * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY * relDiff.x * relDiff.x
			+ 2. * f * fy * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY / 2. * relDiff.x * relDiff.y
			+ 2. * f * fz * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY / 2. * relDiff.x * relDiff.z
		;
		negRelDiff2.y = -f * fy * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY * relDiff.w * relDiff.w
			+ 2. * fy * WARP_BUBBLE_VELOCITY / 2. * relDiff.w * relDiff.x
		;
		negRelDiff2.z = -f * fz * WARP_BUBBLE_VELOCITY * WARP_BUBBLE_VELOCITY * relDiff.w * relDiff.w
			+ 2. * fz * WARP_BUBBLE_VELOCITY / 2. * relDiff.w * relDiff.x
		;
#endif
		rel += DLAMBDA * relDiff;
		relDiff -= DLAMBDA * negRelDiff2;
	}

	$assign
}

		</script>
		<script id='draw-light-vsh' type='x-shader/x-vertex'>
attribute vec2 vtx;
varying vec2 tc;
uniform mat4 mvMat;
uniform mat4 projMat;
void main() {
	tc = vtx;
	gl_Position = projMat * mvMat * vec4(vtx.x, vtx.y, 0., 1.); 
}
		</script>
		<script id='draw-light-fsh' type='x-shader/x-fragment'>
uniform sampler2D posTex;
uniform samplerCube cubeTex;
varying vec2 tc;

void main() {
	vec4 rel = texture2D(posTex, tc);
	
#if 0
	//warn if the light ended up in the event horizon
	if (rel.x <= EVENT_HORIZON_RADIUS) {
		gl_FragColor = vec4(tc.x, tc.y, 0., 1.);
	} else 
#endif
	{
		
		//convert back to euclidian space
		vec3 result = FROM_COORDINATES(rel).xyz;
		
		//convert from black-hole-centered to view-centered
		result += COORDINATE_CENTER;
		
		//with distortion
		gl_FragColor = textureCube(cubeTex, result);
		
		//no distortion
	//	gl_FragColor = textureCube(cubeTex, pos);

		//difference
	//	vec4 color = textureCube(cubeTex, result) - textureCube(cubeTex, pos);
	//	gl_FragColor = vec4(abs(color.x), abs(color.y), abs(color.z), abs(color.w));
	}
}
		</script>
		<script id='cube-vsh' type='x-shader/x-vertex'>
attribute vec3 vtx;
varying vec3 vtxv;
uniform mat4 mvMat;
uniform mat4 projMat;
void main() {
	vtxv = vtx;
	gl_Position = projMat * mvMat * vec4(vtx, 1.);
}
		</script>
		<script id='cube-fsh' type='x-shader/x-fragment'>
precision mediump float;
varying vec3 vtxv;
uniform samplerCube tex;
void main() {
	gl_FragColor = textureCube(tex, vtxv);
	gl_FragColor.w = 1.; 
}
		</script>

		<style type='text/css'>

body {
	background-color:black;
	color:white;
}

a:link {
	cursor:pointer;
	color:#00FFFF;
}

a:visited {
	cursor:pointer;
	color:#00FFFF;
}

a:hover {
	cursor:pointer;
	color:#00FFFF;
}

a:active {
	cursor:pointer;
	color:#00FFFF;
}
	
		</style>
	</head>
	<body style='margin:0px; overflow:hidden'>
		<div id='panel' style='overflow-x:hidden; width:400px; z-index:1, width:300px; position:absolute; background-color:rgba(0,0,0,.75)'>
		</div>
		<div id='webglfail' style='display:none'>
			Sorry, your browser does not support WebGL<br>
			Try one of these other, better browsers:<br>
			<a href='http://www.google.com/chrome'>Chrome</a><br>
			<a href='http://www.mozilla.org/firefox'>Firefox</a><br>
			<a href='http://www.apple.com/safari'>Safari</a><br>
			<b>Opera Users:</b><br>
			Enter "opera:config" in the address bar.<br>
			In the "User Prefs" section set both "Enable Hardware Acceleration" and "Enable WebGL" to "1" and then click "Save".<br>
			It is still buggy.<br>
			<b>IE Users:</b><br>
			Sorry guys, IE doesn't plan to support WebGL.<br>
			Consider using a more <a href='http://www.w3schools.com/browsers/browsers_stats.asp'>standard compliant</a> browser.<br>
		</div>
	</body>
</html>
