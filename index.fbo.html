<!DOCTYPE html>
<html>
	<head>
		<title>Black Hole Iterative Skymap - WebGL</title>

		<meta charset='UTF-8'>
		<script type='text/javascript' src='../js/jquery-1.10.0.min.js'></script>
		<script type='text/javascript' src='../js/util.js'></script>
		<script type='text/javascript' src='../js/gl-matrix-min.js'></script>
		<script type='text/javascript' src='../js/webgl-debug.js'></script>
		<script type='text/javascript' src='../js/gl-util.js'></script>
		<script type='text/javascript' src='../js/gl-util-pingpong.js'></script>
		<script type='text/javascript' src='../js/mouse3d.js'></script>
		<script type='text/javascript' src='main.fbo.js'></script>
		
<script type='text/javascript'>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-17312646-1']);
_gaq.push(['_trackPageview']);
(function() {
	var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
		<script id='shader-common' type='x-shader/x-fragment'>
float tanh(float x) {
	float exp2x = exp(2. * x);
	return (exp2x - 1.) / (exp2x + 1.);
}

float sech(float x) {
	float expx = exp(x);
	return 2. * expx / (expx * expx + 1.);
}

float sechSq(float x) {
	float y = sech(x);
	return y * y;
}
		</script>
		<script id='cube-vsh' type='x-shader/x-vertex'>
attribute vec2 vertex;
varying vec2 uv;
uniform mat4 projMat;
uniform vec4 angle;
const mat3 viewMatrix = mat3(
	0., 0., -1.,
	1., 0., 0., 
	0., -1., 0.);
vec3 qtransform( vec4 q, vec3 v ){ 
	return v + 2.0*cross(cross(v, q.xyz ) + q.w*v, q.xyz);
}
void main() {
	uv = vertex;
	vec3 vtx3 = vec3(vertex * 2. - 1., 1.);
	vtx3 = qtransform(vec4(angle.xyz, -angle.w), vtx3);
	vtx3 = viewMatrix * vtx3;
	vec4 vtx4 = vec4(vtx3, 1.);
	gl_Position = projMat * vtx4;
}
		</script>
		<script id='cube-fsh' type='x-shader/x-fragment'>
varying vec2 uv;
uniform samplerCube skyTex;
uniform sampler2D lightVelTex;
uniform vec4 viewAngle;
const mat3 viewMatrixInv = mat3(
	0., 1., 0.,
	0., 0., -1.,
	-1., 0., 0.);
vec3 qtransform( vec4 q, vec3 v ){ 
	return v + 2.0*cross(cross(v, q.xyz ) + q.w*v, q.xyz);
}
void main() {
	vec3 dir = texture2D(lightVelTex, uv).xyz;
	dir = qtransform(vec4(viewAngle.xyz, viewAngle.w), dir);
	dir = viewMatrixInv * dir;
	gl_FragColor.xyz = textureCube(skyTex, dir).xyz;
	gl_FragColor.w = 1.; 
}
		</script>
		<script id='Black_Hole:Alcubierre_Warp_Drive_Bubble:reset:pos:vel:vsh' type='x-shader/x-vertex'>
attribute vec2 vertex;
varying vec3 vtxv;
uniform mat3 rotation;
void main() {
	vtxv = rotation * vec3(vertex * 2. - 1., 1.);
	gl_Position = vec4(vertex * 2. - 1., 0., 1.);
}
		</script>
		<script id='Black_Hole:reset:pos:fsh' type='x-shader/x-fragment'>
#extension GL_OES_texture_float : enable
varying vec3 vtxv;
uniform float objectDist;
void main() {
	vec3 dir = normalize(vtxv);
	gl_FragColor.xyz = dir;
	gl_FragColor.x -= objectDist;
	gl_FragColor.w = 0.;
}
		</script>
		<script id='Alcubierre_Warp_Drive_Bubble:reset:pos:fsh' type='x-shader/x-fragment'>
#extension GL_OES_texture_float : enable
varying vec3 vtxv;
void main() {
	vec3 dir = normalize(vtxv);
	gl_FragColor.xyz = dir;
	gl_FragColor.w = 0.;
}
		</script>
		<script id='Black_Hole:reset:vel:fsh' type='x-shader/x-fragment'>
uniform float objectDist;
uniform float blackHoleMass;
		</script>
		<script id='Alcubierre_Warp_Drive_Bubble:reset:vel:fsh' type='x-shader/x-fragment'>
uniform float objectDist;
uniform float warpBubbleThickness;
uniform float warpBubbleVelocity;
uniform float warpBubbleRadius;
		</script>
		<script id='Black_Hole:Alcubierre_Warp_Drive_Bubble:reset:vel:fsh' type='x-shader/x-fragment'>
varying vec3 vtxv;
void main() {
	vec3 vel = normalize(vtxv);
	gl_FragColor.xyz = vel;
		</script>
		<script id='Black_Hole:reset:vel:fsh' type='x-shader/x-fragment'>
//when initializing our metric:
//g_ab v^a v^b = 0 for our metric g
// (-1 + 2M/r) vt^2 + (vx^2 + vy^2 + vz^2) / (1 - 2M/r) = 0
// (1 - 2M/r) vt^2 = (vx^2 + vy^2 + vz^2) / (1 - 2M/r)
// vt^2 = (vx^2 + vy^2 + vz^2) / (1 - 2M/r)^2
// vt = ||vx,vy,vz|| / (1 - 2M/r)
	vec3 pos = vel;
	pos.x -= objectDist;
	float r = length(pos);
	float oneMinus2MOverR = 1. - 2. * blackHoleMass / r;
	gl_FragColor.w = 1. / oneMinus2MOverR;
}
		</script>
		<script id='Alcubierre_Warp_Drive_Bubble:reset:vel:fsh' type='x-shader/x-fragment'>
	vec3 pos = vel;
	float r = length(pos - vec3(objectDist,0.,0.));
	float sigmaFront = warpBubbleThickness * (r + warpBubbleRadius);
	float sigmaCenter = warpBubbleThickness * r;
	float sigmaBack = warpBubbleThickness * (r - warpBubbleRadius);
	float tanhSigmaCenter = tanh(sigmaCenter);
	float f = (tanh(sigmaFront) - tanh(sigmaBack)) / (2. * tanhSigmaCenter);
	float sechDiff = sechSq(sigmaFront) - sechSq(sigmaBack);
	float dfScalar = sechDiff / (2. * r * tanhSigmaCenter);				
	float vf = f * warpBubbleVelocity;
	float vf2 = vf * vf;
	gl_FragColor.w = 
		(warpBubbleVelocity * f + sqrt(
			vf2 * (1. + vel.x * vel.x) + 1.
		)) / (-1. + vf2);
}
		</script>
		<script id='Black_Hole:Alcubierre_Warp_Drive_Bubble:iterate:pos:vel:vsh' type='x-shader/x-vertex'>
#extension GL_OES_texture_float : enable
attribute vec2 vertex;
varying vec2 uv;
varying vec3 vtxv;
uniform mat3 rotation;
void main() {
	uv = vertex;
	vtxv = rotation * vec3(vertex * 2. - 1., 1.);
	gl_Position = vec4(vertex * 2. - 1., 0., 1.);
}
		</script>
		<script id='Black_Hole:Alcubierre_Warp_Drive_Bubble:iterate:pos:vel:fsh' type='x-shader/x-fragment'>
varying vec2 uv;
varying vec3 vtxv;
uniform float deltaLambda;
uniform float objectDist;
uniform sampler2D lightPosTex;
uniform sampler2D lightVelTex;
		</script>
		<script id='Black_Hole:iterate:vel:fsh' type='x-shader/x-fragment'>
uniform float blackHoleMass;
		</script>
		<script id='Alcubierre_Warp_Drive_Bubble:iterate:vel:fsh' type='x-shader/x-fragment'>
uniform float warpBubbleThickness;
uniform float warpBubbleRadius;
uniform float warpBubbleVelocity;
		</script>
		<script id='Black_Hole:Alcubierre_Warp_Drive_Bubble:iterate:pos:vel:fsh' type='x-shader/x-fragment'>
void main() {
	vec4 pos = texture2D(lightPosTex, uv);
	vec4 vel = texture2D(lightVelTex, uv);
		</script>
		<script id='Black_Hole:Alcubierre_Warp_Drive_Bubble:iterate:pos:fsh' type='x-shader/x-fragment'>
	gl_FragColor = pos + deltaLambda * vel;
}
		</script>
		<script id='Black_Hole:iterate:vel:fsh' type='x-shader/x-fragment'>
	float r = length(pos.xyz);
	float oneMinus2MOverR = 1. - 2.*blackHoleMass/r;			
	float posDotVel = dot(pos.xyz, vel.xyz);
	float velDotVel = dot(vel.xyz, vel.xyz);
	float r2 = r * r;
	float invR2M = 1. / (r * oneMinus2MOverR);
	float rMinus2MOverR2 = oneMinus2MOverR / r;
	float MOverR2 = blackHoleMass / r2;
	gl_FragColor.x = vel.x - deltaLambda * MOverR2 * (rMinus2MOverR2 * pos.x * vel.w * vel.w + invR2M * (pos.x * velDotVel - 2. * vel.x * posDotVel));
	gl_FragColor.y = vel.y - deltaLambda * MOverR2 * (rMinus2MOverR2 * pos.y * vel.w * vel.w + invR2M * (pos.y * velDotVel - 2. * vel.y * posDotVel));
	gl_FragColor.z = vel.z - deltaLambda * MOverR2 * (rMinus2MOverR2 * pos.z * vel.w * vel.w + invR2M * (pos.z * velDotVel - 2. * vel.z * posDotVel));
	gl_FragColor.w = vel.w + deltaLambda * 2. * MOverR2 * invR2M * posDotVel * vel.w;
}
		</script>
		<script id='Alcubierre_Warp_Drive_Bubble:iterate:vel:fsh' type='x-shader/x-fragment'>
	float r = length(pos.xyz);
	float sigmaFront = warpBubbleThickness * (r + warpBubbleRadius);
	float sigmaCenter = warpBubbleThickness * r;
	float sigmaBack = warpBubbleThickness * (r - warpBubbleRadius);
	float tanhSigmaCenter = tanh(sigmaCenter);
	float f = (tanh(sigmaFront) - tanh(sigmaBack)) / (2. * tanhSigmaCenter);
	float sechDiff = sechSq(sigmaFront) - sechSq(sigmaBack);
	float dfScalar = sechDiff / (2. * r * tanhSigmaCenter);
	vec4 fv;
	fv.xyz = warpBubbleThickness * pos.xyz * dfScalar;
	fv.t = -warpBubbleVelocity * warpBubbleThickness * pos.x * dfScalar;
	gl_FragColor.x = vel.x - deltaLambda * ((f * f * f * fv.x * warpBubbleVelocity * warpBubbleVelocity * warpBubbleVelocity * warpBubbleVelocity - f * fv.x * warpBubbleVelocity * warpBubbleVelocity - fv.t * warpBubbleVelocity) * vel.t * vel.t
		- 2. * f * f * fv.x * warpBubbleVelocity * warpBubbleVelocity * warpBubbleVelocity * vel.t * vel.x
		- 2. * (f * f * fv.y * warpBubbleVelocity * warpBubbleVelocity * warpBubbleVelocity + fv.y * warpBubbleVelocity) / 2. * vel.t * vel.y
		- 2. * (f * f * fv.z * warpBubbleVelocity * warpBubbleVelocity * warpBubbleVelocity + fv.z * warpBubbleVelocity) / 2. * vel.t * vel.z
		+ f * fv.x * warpBubbleVelocity * warpBubbleVelocity * vel.x * vel.x
		+ 2. * f * fv.y * warpBubbleVelocity * warpBubbleVelocity / 2. * vel.x * vel.y
		+ 2. * f * fv.z * warpBubbleVelocity * warpBubbleVelocity / 2. * vel.x * vel.z
	);
	gl_FragColor.y = vel.y + deltaLambda * (f * fv.y * warpBubbleVelocity * warpBubbleVelocity * vel.t * vel.t
		+ 2. * fv.y * warpBubbleVelocity / 2. * vel.t * vel.x
	);
	gl_FragColor.z = vel.z + deltaLambda * (f * fv.z * warpBubbleVelocity * warpBubbleVelocity * vel.t * vel.t
		+ 2. * fv.z * warpBubbleVelocity / 2. * vel.t * vel.x
	);
	gl_FragColor.w = vel.t - deltaLambda * (f * f * fv.x * warpBubbleVelocity * warpBubbleVelocity * warpBubbleVelocity * vel.t * vel.t
		- 2. * f * fv.x * warpBubbleVelocity * warpBubbleVelocity * vel.t * vel.x
		- 2. * f * fv.y * warpBubbleVelocity * warpBubbleVelocity / 2. * vel.t * vel.y
		- 2. * f * fv.z * warpBubbleVelocity * warpBubbleVelocity / 2. * vel.t * vel.z
		+ fv.x * warpBubbleVelocity * vel.x * vel.x
		+ 2. * fv.y * warpBubbleVelocity / 2. * vel.x * vel.y
		+ 2. * fv.z * warpBubbleVelocity / 2. * vel.x * vel.z
	);
}
		</script>
		<style type='text/css'>
body {
	background-color:black;
	color:white;
}

a:link {
	cursor:pointer;
	color:#00FFFF;
}

a:visited {
	cursor:pointer;
	color:#00FFFF;
}

a:hover {
	cursor:pointer;
	color:#00FFFF;
}

a:active {
	cursor:pointer;
	color:#00FFFF;
}
	
		</style>
	</head>
	<body style='margin:0px; overflow:hidden'>
		<div id='panel' style='width:400px; position:absolute; background-color:rgba(0,0,0,.25)'>
			<select id='objectTypes'></select><br>
			Iteration d/dLambda: <input id='deltaLambda'/><br>
			Object Distance (m): <input id='objectDist'/><br>
			Black Hole Mass (kg): <input id='blackHoleMass'/><br>
			Warp Bubble Thickness: <input id='warpBubbleThickness'/><br>
			Warp Bubble Velocity (c): <input id='warpBubbleVelocity'/><br>
			Warp Bubble Radius: <input id='warpBubbleRadius'/><br>
			<button id='reset'>Reset</button><br>
			<!-- button id='pause'>Pause</button><br -->
			<!-- Update: <progress id='update-progress' max='100' value='0'></progress><br> -->
		</div>
		<div id='webglfail' style='display:none'>
			Sorry, your browser does not support WebGL<br>
			Try one of these other, better browsers:<br>
			<a href='http://www.google.com/chrome'>Chrome</a><br>
			<a href='http://www.mozilla.org/firefox'>Firefox</a><br>
			<a href='http://www.apple.com/safari'>Safari</a><br>
			<b>Opera Users:</b><br>
			Enter "opera:config" in the address bar.<br>
			In the "User Prefs" section set both "Enable Hardware Acceleration" and "Enable WebGL" to "1" and then click "Save".<br>
			It is still buggy.<br>
			<b>IE Users:</b><br>
			Sorry guys, IE doesn't plan to support WebGL.<br>
			Consider using a more <a href='http://www.w3schools.com/browsers/browsers_stats.asp'>standard compliant</a> browser.<br>
		</div>
	</body>
</html>
